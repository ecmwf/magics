
/******************************  LICENSE  *******************************

 * (C) Copyright 1996-2017 ECMWF.
 * 
 * This software is licensed under the terms of the Apache Licence Version 2.0
 * which can be obtained at http://www.apache.org/licenses/LICENSE-2.0. 
 * In applying this licence, ECMWF does not waive the privileges and immunities 
 * granted to it by virtue of its status as an intergovernmental organisation nor
 * does it submit to any jurisdiction.

 *******************************  LICENSE  *******************************/

/*! \\file InputMatrixRegularInterpretorAttributes.h
    \\brief Definition of InputMatrixRegularInterpretor Attributes class.

    This file is automatically generated.
    Do Not Edit!
*/

#include "MagRequest.h" 
#include "InputMatrixRegularInterpretorWrapper.h"
#include "MagicsParameter.h"
#include "Factory.h"
#include "MagTranslator.h"

using namespace magics;


InputMatrixRegularInterpretorWrapper::InputMatrixRegularInterpretorWrapper(): inputmatrixregularinterpretor_(new InputMatrixRegularInterpretor())

{

	
	
	
} 
InputMatrixRegularInterpretorWrapper::InputMatrixRegularInterpretorWrapper(InputMatrixRegularInterpretor* inputmatrixregularinterpretor): inputmatrixregularinterpretor_(inputmatrixregularinterpretor)
{
	
	
} 

InputMatrixRegularInterpretorWrapper::~InputMatrixRegularInterpretorWrapper()
{
	
}

void InputMatrixRegularInterpretorWrapper::set(const MagRequest& request)
{
	
	

	if  (request.countValues("INPUT_FIELD_INITIAL_LATITUDE") ) {
		double latitude_value = request("INPUT_FIELD_INITIAL_LATITUDE");
		inputmatrixregularinterpretor_->latitude_ = latitude_value;
		}
	doublearray  latitudes_value;
	for (int i = 0; i < request.countValues("INPUT_LATITUDES_LIST"); i++)
		latitudes_value.push_back((double)request("INPUT_LATITUDES_LIST", i));
	if ( !latitudes_value.empty() ) 
		inputmatrixregularinterpretor_->latitudes_ = latitudes_value;
	doublearray  longitudes_value;
	for (int i = 0; i < request.countValues("INPUT_LONGITUDES_LIST"); i++)
		longitudes_value.push_back((double)request("INPUT_LONGITUDES_LIST", i));
	if ( !longitudes_value.empty() ) 
		inputmatrixregularinterpretor_->longitudes_ = longitudes_value;
	if  (request.countValues("INPUT_FIELD_INITIAL_LONGITUDE") ) {
		double longitude_value = request("INPUT_FIELD_INITIAL_LONGITUDE");
		inputmatrixregularinterpretor_->longitude_ = longitude_value;
		}
	if  (request.countValues("INPUT_FIELD_LATITUDE_STEP") ) {
		double latitude_step_value = request("INPUT_FIELD_LATITUDE_STEP");
		inputmatrixregularinterpretor_->latitude_step_ = latitude_step_value;
		}
	if  (request.countValues("INPUT_FIELD_LONGITUDE_STEP") ) {
		double longitude_step_value = request("INPUT_FIELD_LONGITUDE_STEP");
		inputmatrixregularinterpretor_->longitude_step_ = longitude_step_value;
		}
	if  (request.countValues("INPUT_FIELD_INITIAL_Y") ) {
		double y_first_value = request("INPUT_FIELD_INITIAL_Y");
		inputmatrixregularinterpretor_->y_first_ = y_first_value;
		}
	if  (request.countValues("INPUT_FIELD_FINAL_X") ) {
		double x_last_value = request("INPUT_FIELD_FINAL_X");
		inputmatrixregularinterpretor_->x_last_ = x_last_value;
		}
	if  (request.countValues("INPUT_FIELD_FINAL_Y") ) {
		double y_last_value = request("INPUT_FIELD_FINAL_Y");
		inputmatrixregularinterpretor_->y_last_ = y_last_value;
		}
	doublearray  x_coords_value;
	for (int i = 0; i < request.countValues("INPUT_FIELD_X_LIST"); i++)
		x_coords_value.push_back((double)request("INPUT_FIELD_X_LIST", i));
	if ( !x_coords_value.empty() ) 
		inputmatrixregularinterpretor_->x_coords_ = x_coords_value;
	doublearray  y_coords_value;
	for (int i = 0; i < request.countValues("INPUT_FIELD_Y_LIST"); i++)
		y_coords_value.push_back((double)request("INPUT_FIELD_Y_LIST", i));
	if ( !y_coords_value.empty() ) 
		inputmatrixregularinterpretor_->y_coords_ = y_coords_value;
	if  (request.countValues("INPUT_FIELD_INITIAL_X") ) {
		double x_first_value = request("INPUT_FIELD_INITIAL_X");
		inputmatrixregularinterpretor_->x_first_ = x_first_value;
		}
	if  (request.countValues("INPUT_FIELD_INITIAL_Y_DATE") ) {
		string y_first_date_value = request("INPUT_FIELD_INITIAL_Y_DATE");
		inputmatrixregularinterpretor_->y_first_date_ = y_first_date_value;
		}
	if  (request.countValues("INPUT_FIELD_FINAL_X_DATE") ) {
		string x_last_date_value = request("INPUT_FIELD_FINAL_X_DATE");
		inputmatrixregularinterpretor_->x_last_date_ = x_last_date_value;
		}
	if  (request.countValues("INPUT_FIELD_FINAL_Y_DATE") ) {
		string y_last_date_value = request("INPUT_FIELD_FINAL_Y_DATE");
		inputmatrixregularinterpretor_->y_last_date_ = y_last_date_value;
		}
	if  (request.countValues("INPUT_FIELD_INITIAL_X_DATE") ) {
		string x_first_date_value = request("INPUT_FIELD_INITIAL_X_DATE");
		inputmatrixregularinterpretor_->x_first_date_ = x_first_date_value;
		}
	if  (request.countValues("INPUT_FIELD_Y_STEP") ) {
		double y_step_value = request("INPUT_FIELD_Y_STEP");
		inputmatrixregularinterpretor_->y_step_ = y_step_value;
		}
	if  (request.countValues("INPUT_FIELD_X_STEP") ) {
		double x_step_value = request("INPUT_FIELD_X_STEP");
		inputmatrixregularinterpretor_->x_step_ = x_step_value;
		}
	
	
}

void InputMatrixRegularInterpretorWrapper::print(ostream& out)  const
{
	out << "InputMatrixRegularInterpretorWrapper[]";
}


    



